This is my attempt at a solution to the keyboard encipher homework assignment. Almost immediately after seeing the problem I settled on leveraging the NumPy Python library in my solution and it is the only external library required for this program. I am a firm believer in the KISS (keep it simple, stupid) philosophy and seek not to reinvent the wheel for no reason - there's no need for a CNC router if some cardboard and glue will do just fine. NumPy comes equipped out of the box with optimized vector and matrix operations to neatly handle the prescribed transformations and a reasonable level of efficiency was a goal while completing the work. On my personal computer the program can process a cipher and input string each consisting of a million characters in roughly 11 seconds including validation. That time drops to roughly 8 seconds if validation is not required. With strings or collections of that size and larger limiting the amount of iterations is important, and I made it a point to only try and iterate each string a minimum number of times. I have some ideas that could boost performance as the scale increases, but given the time limit for completing the work I didn't want to get too into the weeds. Reasonable modularity was also a concern and was the primary motivating factor behind including validation in the program. Validating the input string and cipher does require an additional iteration of each but it also allows the program to easier adapt to future user-supplied input instead of hard-coded values. All of the logic for performing the actual operations exists in its own module and adding a new operator (transpose, for example) to the cipher is as easy as creating a corresponding function in operations.py, updating the if statement in transformer.py, and adding the operator character to the VALID_CIPHER_CHARACTERS array in validation.py. If the number of operations grows significantly then the if statement will likely become a little unwieldy and another approach would likely be best, but for the purposes here it seemed a simple, tractable solution.

The entry point to run the application is the main.py script in the root directory - simply execute that and you're off to the races! The CIPHER and INPUT_STRING variables are also in main.py to provide different inputs. Test discovery via python -m unittest discover can be run in the root directory to execute all of the unit tests if desired.